from enum import Enum
from typing import Any, Dict, List, Optional

from fastapi import APIRouter, Depends, Query
from fastapi.security import APIKeyHeader
from sqlalchemy.orm import Session

from api.exceptions import BadRequestError, NotFoundError
from api.models import Comment, PostDownloadPage
from database import utils as db_utils
from database.db import get_session
from database.exceptions import TokenNotFoundError
from .base import api_handler, raise_error
from .models import PaginatedResult, PostStatistics, SearchItem
from .utils import decode_html_entities

api_key_header = APIKeyHeader(
    name="X-API-Token",  # The name of the header
    description=(
        "The user token for authentication. "
        "It is a 32-character string that is generated by the server."
    ),
    auto_error=False  # let the developer manually handle the error
)


def get_api_token(
        x_api_token: Optional[str] = Depends(api_key_header),
        db: "Session" = Depends(get_session)
) -> str:
    """Get API token from the request header."""
    if not x_api_token:
        raise_error(
            401,
            message="X-API-Token header is required for authentication."
        )
    try:
        db_utils.verify_token(db, x_api_token)
    except TokenNotFoundError:
        raise_error(401, message="Invalid API token.")
    return x_api_token


def get_common_search_queries(
        query: str = Query(
            ...,
            title="Query",
            description="The query to search for.",
            min_length=1,
            example="clash of clans",
            alias="q"
        ),
        page: Optional[int] = Query(
            None,
            title="Page",
            description="The page number to fetch. Default is 1.",
            gt=0
        )
) -> Dict[str, Any]:
    return {"query": query, "page": page}


router = APIRouter(
    tags=["Posts"],
    prefix="/posts",
    dependencies=[Depends(get_api_token)],
    responses={
        401: {"description": "Unauthorized, invalid or missing API token."},
    }
)


class CommentsOrder(str, Enum):
    """Order comments in `ascending` or `descending` order."""

    ASC = "asc"
    DESC = "desc"


class CommentsOrderBy(str, Enum):
    """Order comments by different fields (e.g. `date`)."""

    DATE = "date"
    DATE_GMT = "date_gmt"
    ID = "id"


@router.get(
    "/search",
    response_model=PaginatedResult,
    response_model_exclude_unset=True,  # exclude `None` values from the response
    summary="Search for a post on farsroid.com.",
    response_description="The search results.",
    status_code=200
)
async def search(
        common_queries: Dict[str, Any] = Depends(get_common_search_queries),
        per_page: Optional[int] = Query(
            None,
            title="Per Page",
            description=(
                    "The number of results per page. "
                    "If not specified, the default is 10 results per page. "
                    "The maximum is 100 results per page."
            ),
            gt=0
        )
) -> PaginatedResult:
    query, page = common_queries["query"], common_queries["page"]
    res = await api_handler.search(query, page, per_page)
    items = [
        SearchItem(
            id=item["id"],
            title=decode_html_entities(item["title"]),
            url=item["url"]
        )
        for item in res
    ]
    return PaginatedResult(
        page=page or 1,  # Default page is 1
        items_count=len(items),
        items=items
    )


@router.get(
    "/search/legacy",
    response_model=PaginatedResult,
    summary="Search for a post on farsroid.com using the legacy search API.",
    response_description="The search results.",
    status_code=200
)
async def legacy_search(
        common_queries: Dict[str, Any] = Depends(get_common_search_queries)
) -> PaginatedResult:
    query, page = common_queries["query"], common_queries["page"]
    items, total_pages = await api_handler.legacy_search(query, page)
    return PaginatedResult(
        total_pages=total_pages,
        page=page or 1,  # Default page is 1
        items_count=len(items),
        items=items
    )


@router.get(
    "/{post_id}/dp",
    response_model=PostDownloadPage,
    summary="Get a post's download page (dp) by its ID.",
    response_description="The post's download page data.",
    status_code=200
)
async def get_post(
        post_id: int = Query(
            ...,
            title="Post ID",
            description="The ID of the post to fetch.",
            example=10555,
            gt=0
        )
) -> PostDownloadPage:
    try:
        return await api_handler.get_post(post_id)
    except NotFoundError:
        raise_error(404, message=f"post {post_id} not found")


@router.get(
    "/{post_id}/stats",
    response_model=PostStatistics,
    summary="Get statistics for a post stored on farsroid.com database.",
    response_description="The statistics for the post such as downloads, views, etc.",
    status_code=200
)
async def get_post_statistics(
        post_id: int = Query(
            ...,
            title="Post ID",
            description=(
                    "The ID of the post to get statistics for. "
                    "This can be found in search results."
            ),
            example=10555,
            gt=0
        )
) -> PostStatistics:
    try:
        res = await api_handler.get_post_statistics(post_id)
        # farsroid API returns 400 if the post is not found!
    except (BadRequestError, NotFoundError):
        res = None
    if not res:
        # TODO: extend the error details (e.g. the post ID, status code, etc.)
        raise_error(404, message=f"post {post_id} not found")
    data = res["data"][0]
    return PostStatistics(
        post_id=data["post_id"],
        views=data["views"],
        likes=data["likes"],
        total_downloads=data["download"],
        monthly_downloads=data["download_month"],
        weekly_downloads=data["download_week"],
        today_downloads=data["download_today"]
    )


@router.get(
    "/{post_id}/comments",
    response_model=List[Comment],
    summary="Get the comments that were made on a post (approved ones).",
    response_description="The list of comments.",
    status_code=200
)
async def get_post_comments(
        post_id: int = Query(
            ...,
            title="Post ID",
            description=(
                    "The ID of the post to get comments for. "
                    "This can be found in search results."
            ),
            example=10555,
            gt=0
        ),
        page: int = Query(
            1,
            title="Page",
            description="The page number to fetch.",
            gt=0,
            lt=101
        ),
        per_page: int = Query(
            10,
            title="Per Page",
            description="The number of results per page.",
            gt=0,
            lt=101
        ),
        search_: Optional[str] = Query(
            None,
            title="Search",
            description="The search query to filter comments by.",
            min_length=3,
        ),
        order: Optional[CommentsOrder] = Query(
            None,
            title="Order",
            description="The order to fetch comments in.",
            example="desc"
        ),
        order_by: Optional[CommentsOrderBy] = Query(
            None,
            title="Order By",
            description="The field to order comments by.",
            example="date_gmt"
        )
) -> List[Comment]:
    # TODO: add pagination and sorting of comments => DONE
    try:
        return await api_handler.get_comments_by(
            "post",
            post_id,
            page=page,
            per_page=per_page,
            search=search_,
            order_by=order_by.value if order_by else None,
            order=order.value if order else None
        )
    except (BadRequestError, NotFoundError):
        raise_error(404, message=f"post {post_id} not found")
